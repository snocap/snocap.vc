---
import { strings } from "data/strings";
import { t } from "src/utils/i18n";

const groups = [
  [
    {
      title: t("Apply for funding and build with us."),
      text: t("Founders"),
      href: "#founders",
    },
    {
      title: t("World-class partners and programs."),
      text: t("Ecosystem"),
      href: "#ecosystem",
    },
  ],
  [
    {
      title: t("An investment team that gets deeptech."),
      text: t("Team"),
      href: "#team",
    },
    {
      title: t("Learn about our portfolio companies."),
      text: t("Portfolio"),
      href: "#portfolio",
    },
  ],
  [
    {
      title: t("Read our latest articles and news."),
      text: t("News"),
      href: "#news",
    },
    {
      title: t("Join us for live, in-person events."),
      text: t("Events"),
      href: "#events",
    },
  ],
];
---

<nav-collabsible {...Astro.props}>
  <h3 class="nav-subtitle" title={t(strings.oneLiner)}>
    {t(strings.oneLiner)}
  </h3>
  <p class="nav-link-groups">
    {
      groups.map((group) => (
        <span class="nav-link-group">
          {group.map(({ title, text, href }) => (
            <a class="nav-link" href={href} title={title}>
              {text}
            </a>
          ))}
        </span>
      ))
    }
  </p>
</nav-collabsible>

<style>
  nav-collabsible {
    padding: 0 var(--gutter-width) var(--row-gap);
    display: flex;
    flex-direction: row;
    justify-content: space-between;
		align-items: center;
    position: relative;
    z-index: 1;
    width: 100%;
  }
	.nav-subtitle {
		min-height: 4.5rem;
		max-width: 19.8rem;
	}
  p {
    display: flex;
    flex-direction: row;
    column-gap: 2rem;
    padding: 0.5rem 0;
  }
  p span {
    display: flex;
    flex-direction: column;
    row-gap: 0.25rem;
  }
	.nav-link.selected {
		text-decoration: underline;
	}
</style>

<script>

	import { TypewriterClass } from "typewriter-effect";

	declare global {
		class Typewriter extends TypewriterClass {}
	}

	// @ts-ignore
	import Typewriter from "typewriter-effect/dist/core";

	const sections: NodeListOf<HTMLElement> = document.querySelectorAll("section");
	class CollapsibleNav extends HTMLElement {
		private isDragging: boolean;
		private startY: number;
		private startMarginTop: number; 
		private links: NodeListOf<HTMLAnchorElement> = document.querySelectorAll("nav-collabsible a.nav-link");
		private subtitle: HTMLHeadingElement = document.querySelector("nav-collabsible h3")!;
		private typewriter: TypewriterClass;
		private lastLink?: HTMLAnchorElement | null;
		private debounceTimeout?: NodeJS.Timeout

		constructor() {
			super();
			this.isDragging = false;
			this.startY = 0;
			this.startMarginTop = 0;
			this.typewriter = new Typewriter(this.subtitle, { delay: 60 })
			this.determineSelectedSection()
		}

		connectedCallback() {
			window.addEventListener("mousedown", this.onMouseDown);
			window.addEventListener("wheel", this.onScroll);
			window.addEventListener("mouseup", this.onMouseUp);
			window.addEventListener("mousemove", this.onMouseMove);
			window.addEventListener("touchstart", this.onTouchStart, { passive: false });
			window.addEventListener("touchmove", this.onTouchMove, { passive: false });
			window.addEventListener("touchend", this.onTouchEnd);
			window.addEventListener("resize", this.onResize);
			window.addEventListener("hashchange", this.onHashChange);
			window.addEventListener("scroll", this.determineSelectedSection);
		}

		disconnectedCallback() {
			window.removeEventListener("mousedown", this.onMouseDown);
			window.removeEventListener("wheel", this.onScroll);
			window.removeEventListener("mouseup", this.onMouseUp);
			window.removeEventListener("mousemove", this.onMouseMove);
			window.removeEventListener("touchstart", this.onTouchStart);
			window.removeEventListener("touchmove", this.onTouchMove);
			window.removeEventListener("touchend", this.onTouchEnd);
			window.removeEventListener("resize", this.onResize);
			window.removeEventListener("hashchange", this.onHashChange);
			window.removeEventListener("scroll", this.determineSelectedSection);
		}

		updateSubtitle(link: HTMLAnchorElement | null) {
			if (link === this.lastLink) return;
			const text = link ? link.title : this.subtitle.title;
			this.typewriter.stop().deleteAll('natural').typeString(text).start()
			this.lastLink = link;
		}

		debouncedUpdateSubtitle = (link: HTMLAnchorElement | null) => {
			if (this.debounceTimeout) clearTimeout(this.debounceTimeout)
			this.debounceTimeout = setTimeout(() => this.updateSubtitle(link), 350)
		}

		determineSelectedSection = () => {
			let selectedSection = null;
			for (const section of sections) {
				const rect = section.getBoundingClientRect();
				if (
					(rect.top >= 0 && rect.top <= window.innerHeight / 2) ||
					(rect.bottom >= window.innerHeight / 2 && rect.bottom <= window.innerHeight) ||
					(rect.top < 0 && rect.bottom > window.innerHeight)
				) {
					selectedSection = section;
					break;
				}
			}
			if (!selectedSection) {
				return;
			}
			let fallbackToDefault = true;
			this.links.forEach((link) => {
				const previously = this.classList.contains("selected");
				const selected = link.getAttribute("href") === `#${selectedSection.id}`;
				link.classList.toggle("selected", selected);
				if (selected && !previously) {
					this.debouncedUpdateSubtitle(link);
					fallbackToDefault = false;
				}
			});
			if (fallbackToDefault) {
				this.debouncedUpdateSubtitle(null);
			}
		}

		onHashChange = () => {
			this.reactQuicklyToChanges();
		};

		onResize = () => {
			this.reactQuicklyToChanges();
		};

		onMouseDown = (event: MouseEvent) => {
			this.isDragging = true;
			this.startY = event.clientY;
			this.startMarginTop = parseFloat(this.style.marginTop) || 0;
		};

		onMouseUp = () => {
			this.isDragging = false;
		};

		onMouseMove = (event: MouseEvent) => {
			if (!this.isDragging) return;

			const deltaY = event.clientY - this.startY;
			this.updateMarginTop(this.startMarginTop + deltaY);
		};

		onScroll = (event: WheelEvent) => {
			const deltaY = event.deltaY;
			const currentMarginTop = parseFloat(this.style.marginTop) || 0;
			this.updateMarginTop(currentMarginTop - deltaY);
		};

		onTouchStart = (event: TouchEvent) => {
			this.isDragging = true;
			this.startY = event.touches[0].clientY;
			this.startMarginTop = parseFloat(this.style.marginTop) || 0;
		};

		onTouchMove = (event: TouchEvent) => {
			if (!this.isDragging) return;

			event.preventDefault(); // Prevent scrolling while dragging
			const deltaY = event.touches[0].clientY - this.startY;
			this.updateMarginTop(this.startMarginTop + deltaY);
		};

		onTouchEnd = () => {
			this.isDragging = false;
		};

		updateMarginTop(newMarginTop: number) {
			const elementHeight = this.offsetHeight;
			const marginTop = Math.max(-elementHeight, Math.min(0, newMarginTop));
			this.style.marginTop = `${marginTop}px`;
			this.updateBorderOpacity();
		}

		updateBorderOpacity() {
			const currentScrollY = window.scrollY;
			const maxOpacity = 0.2; // Maximum opacity for the box shadow
			const fadeStart = this.offsetHeight; // Start fading within offsetHeight of the top
			const borderOpacity = Math.min(maxOpacity, currentScrollY / fadeStart);
			if (this.parentElement?.parentElement)
				this.parentElement.parentElement.style.borderBottom = `solid 1px rgba(0, 0, 0, ${borderOpacity})`;
		}

		reactQuicklyToChanges() {
			this.updateMarginTop(-window.scrollY)
			this.updateBorderOpacity();
		}
	}

	customElements.define("nav-collabsible", CollapsibleNav);
</script>
