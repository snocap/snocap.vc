---
import { t } from "src/lib/i18n";

const groups = [
  [
    {
      title: t("Apply for funding and build with us"),
      text: t("Founders"),
      href: "#founders",
    },
    {
      title: t("Explore our ecosystem programs and partners"),
      text: t("Ecosystem"),
      href: "#ecosystem",
    },
  ],
  [
    {
      title: t("An investment team that gets deeptech"),
      text: t("Team"),
      href: "#team",
    },
    {
      title: t("Learn about our portfolio companies"),
      text: t("Portfolio"),
      href: "#portfolio",
    },
  ],
  [
    {
      title: t("Read our latest articles and news"),
      text: t("News"),
      href: "#news",
    },
    {
      title: t("Join us for live, in-person events"),
      text: t("Events"),
      href: "#events",
    },
  ],
];
---

<nav-collabsible {...Astro.props}>
  <h3 class="nav-subtitle" title={t("Backing deep science for a better future.")}>
    {t("Backing deep science for a better future.")}
  </h3>
  <p class="nav-link-groups">
    {
      groups.map((group) => (
        <span class="nav-link-group">
          {group.map(({ title, text, href }) => (
            <a class="nav-link" href={href} title={title}>
              {text}
            </a>
          ))}
        </span>
      ))
    }
  </p>
</nav-collabsible>

<style>
  nav-collabsible {
    padding: 0 var(--gutter-width) var(--row-gap);
    display: flex;
    flex-direction: row;
    justify-content: space-between;
		align-items: center;
    position: relative;
    z-index: 1;
    width: 100%;
  }
  h3 {
    max-width: 19.2rem;
  }
  p {
    display: flex;
    flex-direction: row;
    column-gap: 2rem;
    padding: 0.5rem 0;
  }
  p span {
    display: flex;
    flex-direction: column;
    row-gap: 0.25rem;
  }
	.nav-link.selected {
		text-decoration: underline;
	}
</style>
<script>
	const sections: NodeListOf<HTMLElement> = document.querySelectorAll("section");
	class CollapsibleNav extends HTMLElement {
		private isDragging: boolean;
		private startY: number;
		private startMarginTop: number; 
		private links: NodeListOf<HTMLAnchorElement> = document.querySelectorAll("nav-collabsible a.nav-link");
		private subtitle: HTMLHeadingElement = document.querySelector("nav-collabsible h3")!;

		constructor() {
			super();
			this.isDragging = false;
			this.startY = 0;
			this.startMarginTop = 0;
		}

		connectedCallback() {
			window.addEventListener("mousedown", this.onMouseDown);
			window.addEventListener("wheel", this.onScroll);
			window.addEventListener("mouseup", this.onMouseUp);
			window.addEventListener("mousemove", this.onMouseMove);
			window.addEventListener("touchstart", this.onTouchStart, { passive: false });
			window.addEventListener("touchmove", this.onTouchMove, { passive: false });
			window.addEventListener("touchend", this.onTouchEnd);
			window.addEventListener("resize", this.onResize);
			window.addEventListener("hashchange", this.onHashChange);
			window.addEventListener("scroll", this.determineSelectedSection);
		}

		disconnectedCallback() {
			window.removeEventListener("mousedown", this.onMouseDown);
			window.removeEventListener("wheel", this.onScroll);
			window.removeEventListener("mouseup", this.onMouseUp);
			window.removeEventListener("mousemove", this.onMouseMove);
			window.removeEventListener("touchstart", this.onTouchStart);
			window.removeEventListener("touchmove", this.onTouchMove);
			window.removeEventListener("touchend", this.onTouchEnd);
			window.removeEventListener("resize", this.onResize);
			window.removeEventListener("hashchange", this.onHashChange);
			window.removeEventListener("scroll", this.determineSelectedSection);
		}

		updateSubtitle(link: HTMLAnchorElement | null) {
			if (link) {
				this.subtitle.textContent = link.title;
			} else {
				this.subtitle.textContent = this.subtitle.title;
			}
		}

		determineSelectedSection = () => {
			let selectedSection = null;
			for (const section of sections) {
				const rect = section.getBoundingClientRect();
				if (rect.top + rect.height / 2 >= 0 && rect.top + rect.height / 2 < window.innerHeight) {
					selectedSection = section;
					break;
				}
			}
			if (!selectedSection) {
				return;
			}
			let fallbackToDefault = true;
			this.links.forEach((link) => {
				const previously = this.classList.contains("selected");
				const selected = link.getAttribute("href") === `#${selectedSection.id}`;
				link.classList.toggle("selected", selected);
				if (selected && !previously) {
					this.updateSubtitle(link);
					fallbackToDefault = false;
				}
			});
			if (fallbackToDefault) {
				this.updateSubtitle(null);
			}
		}

		onHashChange = () => {
			this.reactQuicklyToChanges();
		};

		onResize = () => {
			this.reactQuicklyToChanges();
		};

		onMouseDown = (event: MouseEvent) => {
			this.isDragging = true;
			this.startY = event.clientY;
			this.startMarginTop = parseFloat(this.style.marginTop) || 0;
		};

		onMouseUp = () => {
			this.isDragging = false;
		};

		onMouseMove = (event: MouseEvent) => {
			if (!this.isDragging) return;

			const deltaY = event.clientY - this.startY;
			this.updateMarginTop(this.startMarginTop + deltaY);
		};

		onScroll = (event: WheelEvent) => {
			const deltaY = event.deltaY;
			const currentMarginTop = parseFloat(this.style.marginTop) || 0;
			this.updateMarginTop(currentMarginTop - deltaY);
		};

		onTouchStart = (event: TouchEvent) => {
			this.isDragging = true;
			this.startY = event.touches[0].clientY;
			this.startMarginTop = parseFloat(this.style.marginTop) || 0;
		};

		onTouchMove = (event: TouchEvent) => {
			if (!this.isDragging) return;

			event.preventDefault(); // Prevent scrolling while dragging
			const deltaY = event.touches[0].clientY - this.startY;
			this.updateMarginTop(this.startMarginTop + deltaY);
		};

		onTouchEnd = () => {
			this.isDragging = false;
		};

		updateMarginTop(newMarginTop: number) {
			const elementHeight = this.offsetHeight;
			const marginTop = Math.max(-elementHeight, Math.min(0, newMarginTop));
			this.style.marginTop = `${marginTop}px`;
			this.updateBorderOpacity();
		}

		updateBorderOpacity() {
			const currentScrollY = window.scrollY;
			const maxOpacity = 0.2; // Maximum opacity for the box shadow
			const fadeStart = this.offsetHeight; // Start fading within offsetHeight of the top
			const borderOpacity = Math.min(maxOpacity, currentScrollY / fadeStart);
			if (this.parentElement?.parentElement)
				this.parentElement.parentElement.style.borderBottom = `solid 1px rgba(0, 0, 0, ${borderOpacity})`;
		}

		reactQuicklyToChanges() {
			this.updateMarginTop(-window.scrollY)
			this.updateBorderOpacity();
		}
	}

	customElements.define("nav-collabsible", CollapsibleNav);
</script>
